import numpy as np
import scipy.sparse as sp
import os.path as osp
import warnings
import urllib.request
import torch
import random
from torch_geometric.data import Data

class PtbDataset:
    """Dataset class manages pre-attacked adjacency matrix on different datasets. Currently only support metattack under 5% perturbation. Note metattack is generated by deeprobust/graph/global_attack/metattack.py. While PrePtbDataset provides pre-attacked graph generate by Zugner, https://github.com/danielzuegner/gnn-meta-attack. The attacked graphs are downloaded from https://github.com/ChandlerBang/pytorch-gnn-meta-attack/tree/master/pre-attacked.

    Parameters
    ----------
    root :
        root directory where the dataset should be saved.
    name :
        dataset name. It can be choosen from ['cora', 'citeseer', 'cora_ml', 'polblogs', 'pubmed']
    attack_method :
        currently this class only support metattack. User can pass 'meta', 'metattack' or 'mettack' since all of them will be interpreted as the same attack.
    seed :
        random seed for splitting training/validation/test.
    """

    def __init__(self, root, name, attack_method='mettack'):
        assert attack_method in ['mettack', 'metattack', 'meta'], \
            'Currently the database only stores graphs perturbed by 5% mettack'

        self.name = name.lower()
        assert self.name in ['cora', 'citeseer', 'polblogs'], \
            'Currently only support cora, citeseer, polblogs'

        self.attack_method = 'mettack' # attack_method
        self.url = 'https://raw.githubusercontent.com/ChandlerBang/pytorch-gnn-meta-attack/master/pre-attacked/{}_{}_0.05.npz'.format(self.name, self.attack_method)
        self.root = osp.expanduser(osp.normpath(root))
        self.data_filename = osp.join(root,
                '{}_{}_0.05.npz'.format(self.name, self.attack_method))
        self.adj = self.load_data()

    def load_data(self):
        if not osp.exists(self.data_filename):
            #self.download_npz()
          print('download_npz')
        print('Loading {} dataset perturbed by 0.05 mettack...'.format(self.name))
        adj = sp.load_npz(self.data_filename)
        warnings.warn('''the adjacency matrix is perturbed, using the data splits under seed 15(default seed for deeprobust.graph.data.Dataset), so if you are going to verify the attacking performance, you should use the same data splits''')
        return adj

    def download_npz(self):
        print('Dowloading from {} to {}'.format(self.url, self.data_filename))
        try:
            urllib.request.urlretrieve(self.url, self.data_filename)
        except:
            raise Exception('''Download failed! Make sure you have
                    stable Internet connection and enter the right name''')


class MyReadPtbData:
    def __init__(self, root, name, ROI_num, attack_method='nettack', ptb_rate=0.05):
        assert attack_method in ['nettack'], \
            ' Currently the database only stores graphs perturbed by nettack'
        self.name = name
        self.attack_method = attack_method
        self.ptb_rate = ptb_rate
        self.ROI = ROI_num
        self.root = osp.expanduser(osp.normpath(root))
        self.features_filename = osp.join(root, '{}_nettack_fea.npz'.format(self.name))
        self.adj_filename = osp.join(root, '{}_nettack_adj.npz'.format(self.name))
        if attack_method == 'nettack':
            self.features, self.edge_attr, self.edge_index = self.load_data()

    def load_data(self):
        if not osp.exists(self.features_filename):
            warnings.warn('no perturbed features dataset!')
        else:
            print('Loading {} features perturbed by {} {}...'.format(self.name, self.ptb_rate, self.attack_method))
            features_csr = sp.load_npz(self.features_filename)
            features = torch.tensor(features_csr.toarray(), dtype=torch.float32)

        if not osp.exists(self.adj_filename):
            warnings.warn('no perturbed structure dataset!')
        else:
            print('Loading {} structure perturbed by {} {}...'.format(self.name, self.ptb_rate, self.attack_method))
            adj_csr = sp.load_npz(self.adj_filename)
            adj = sp.coo_matrix(adj_csr.toarray())
            edge_attr = torch.tensor(adj.data).unsqueeze(1)
            indices = np.vstack((adj.row, adj.col))  # coo format We needed
            edge_index = torch.LongTensor(indices)  # coo format PyG needed
            sub=int(adj.shape[0] / self.ROI)
            batch=[]
            for j in range(sub):
                batch.append([j] * self.ROI)
            batch_torch = torch.from_numpy(np.hstack(batch)).long()
            node_slice = torch.cumsum(torch.from_numpy(np.bincount(batch_torch)), 0)
            node_slice = torch.cat([torch.tensor([0]), node_slice])
            row, _ = edge_index
            # the indices should be splited for every subject-network
            edge_index -= node_slice[batch_torch[row]].unsqueeze(0)
            # edge_noise = np.where(np.array(edge_index[1,:].numpy() >= self.ROI) |
            #                       np.array(edge_index[1,:].numpy() < 0))
            edge_noise = np.where(np.array(edge_attr.numpy() == 1))
            edge_index_quality = torch.tensor(np.delete(edge_index.numpy(), edge_noise[0], axis=1))
            edge_attr_quality = torch.tensor(np.delete(edge_attr.numpy(), edge_noise[0])).unsqueeze(1)

        return features, edge_attr_quality, edge_index_quality


class RandomAttack():

    def __init__(self):
        self.name = 'RandomAttack'

    def attack(self, adj, ratio=0.4):
        print('random attack: ratio=%s' % ratio)
        modified_adj = self._random_add_edges(adj, ratio)
        return modified_adj

    def _random_add_edges(self, adj, add_ratio):

        def sample_zero_forever(mat):
            nonzero_or_sampled = set(zip(*mat.nonzero()))
            while True:
                t = tuple(np.random.randint(0, mat.shape[0], 2))
                if t not in nonzero_or_sampled:
                    yield t
                    nonzero_or_sampled.add(t)
                    nonzero_or_sampled.add((t[1], t[0]))

        def sample_zero_n(mat, n=100):
            itr = sample_zero_forever(mat)
            return [next(itr) for _ in range(n)]

        assert np.abs(adj - adj.T).sum() == 0, "Input graph is not symmetric"
        non_zeros = [(x, y) for x,y in np.argwhere(adj != 0) if x < y] # (x, y)

        added = sample_zero_n(adj, n=int(add_ratio * len(non_zeros)))
        for x, y in added:
            adj[x, y] = 1
            adj[y, x] = 1
        return adj
